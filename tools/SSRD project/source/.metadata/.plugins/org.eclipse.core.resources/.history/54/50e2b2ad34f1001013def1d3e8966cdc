package net.SubSpace.SSDR.Server.Main;


import KnockKnockProtocol;

import java.net.*;
import java.util.List;
import java.util.Random;
import java.io.*;
 
public class ServerThread extends Thread {
    private Socket socket = null;
    Random random = new Random();
 
    public ServerThread(Socket socket) {
    super("ServerThread");
    this.socket = socket;
    }
 
    public void run() {
    	Boolean Connect = false;
    	
        Protocol p = new Protocol();
 
        ServerSocket serverSocket = null;
        try {
            serverSocket = new ServerSocket(4444);
        } catch (IOException e) {
            System.err.println("Could not listen on port: 4444.");
            System.exit(1);
        }
 
        Socket clientSocket = null;
        try {
            clientSocket = serverSocket.accept();
        } catch (IOException e) {
            System.err.println("Accept failed.");
            System.exit(1);
        }
 
        PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);
        BufferedReader in = new BufferedReader(
                new InputStreamReader(
                clientSocket.getInputStream()));
        String inputLine, outputLine;

        out.println("Ready");
        String fromUser, fromServer;

        out.println("Ready");
        try {
        	List LVLlist = Server.LVLlist;
        	boolean hasRead = false;
			while ((fromUser = in.readLine()) != null) {
				File file = null;
			try {
				fromUser = in.readLine();
				if(fromUser == "Read Next")
				{
						if(LVLlist.isEmpty())
						{
							out.println("Done");
							break;
						}
						out.println((file = (File)LVLlist.get(0)).getName());
						LVLlist.remove(0);
						hasRead = true;
				}
				else if(hasRead = true)
				{
					out.println("FILE SIZE:" + file.length());
				}
				else if(fromUser == "Done")
				{
					hasRead = false;
			        out.println("Ready");
				}
				else // Returns long value for processing file. After this is ran it should return a read.
				{
					long userFileSize = Long.parseLong(fromUser);
					if(p.shouldFileBeUpdated(userFileSize, file.getName()))
					{
						byte[] fileInBytes = p.sendFile(file);
						DataOutputStream dout = new DataOutputStream(socket.getOutputStream());
						dout.write(fileInBytes);
					}
					hasRead = false;
				}

			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			}
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        out.close();
        try {
			in.close();
			in.close();
			socket.close();
		} catch (IOException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}

    }
    
    
    
    public void SendFile(File file) throws IOException
    {
        OutputStream os = socket.getOutputStream();
        //os.writeObject((Object)file);
        socket.close();
    }
}